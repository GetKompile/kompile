/*
 * Copyright (c) 2022 Konduit K.K.
 *
 *     This program and the accompanying materials are made available under the
 *     terms of the Apache License, Version 2.0 which is available at
 *     https://www.apache.org/licenses/LICENSE-2.0.
 *
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *     WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *     License for the specific language governing permissions and limitations
 *     under the License.
 *
 *     SPDX-License-Identifier: Apache-2.0
 */

package ai.konduit.pipelinegenerator.main.config.updater;

import ai.konduit.serving.pipeline.util.ObjectMappers;
import org.apache.commons.io.FileUtils;
import org.nd4j.linalg.learning.config.*;
import org.nd4j.linalg.schedule.*;
import picocli.CommandLine;

import java.io.File;
import java.nio.charset.Charset;
import java.util.Collections;
import java.util.concurrent.Callable;

@CommandLine.Command(name = "generate-schedule-config",mixinStandardHelpOptions = false,description = "Generates an updater configuration. Used in combination with samediff training to specify an updater to use.")
public class ScheduleGenerator implements Callable<Integer> {
    @CommandLine.Option(names = {"--scheduler"},description = "The scheduler type: cycle,exponential,fixed,inverse,poly,ramp,sigmoid,step",required = false)
    private String scheduler;
    @CommandLine.Option(names = {"--scheduleType"},description = "The schedule type. Decay per step or epoch. Values are: EPOCH,ITERATION",required = false)
    private ScheduleType scheduleType;
    @CommandLine.Option(names = {"--initialLearningRate"},description = "The initial learning rate for the schedule",required = false)
    private double initialLearningRate;
    @CommandLine.Option(names = {"--maxLearningRate"},description = "The max learning rate for the schedule. Used in cyclic learning to determine the max learning rate to use during a cycle.",required = false)
    private double maxLearningRate;
    @CommandLine.Option(names = {"--cycleLength"},description = "The length of the cycle for the cyclic learning rate schedule.",required = false)
    private int cycleLength;
    @CommandLine.Option(names = {"--annealingLength"},description = "The length of the annealing for the cycle. Used in schedules: cycle",required = false)
    private int annealingLength;
    @CommandLine.Option(names = {"--stepSize"},description = "The step size for decaying the learning rate at each step of the updater. Used in schedulers: sigmoid ",required = false)
    private int stepSize;

    @CommandLine.Option(names = {"--annealingDecay"},description = "The decay rate to use with cyclic learning rate. Used in schedulers: cycle ",required = false)
    private double annealingDecay;

    @CommandLine.Option(names = {"--gamma"},description = "The exponent to decay the learning rate at. Used in schedulers: exponential",required = false)
    private double gamma;

    @CommandLine.Option(names = {"--power"},description = "The power to decay by Used in updaters: inverse",required = false)
    private double power;

    @CommandLine.Option(names = {"--maxIterations"},description = "The max number of iterations to decay the learning rate by. Used in schedulers: poly",required = false)
    private int maxIterations;

    @CommandLine.Option(names = {"--decayRate"},description = "The decay rate at each step. Used in schedules: step",required = false)
    private double decayRate;

    @CommandLine.Option(names = {"--step"},description = "Used in schedules: poly",required = false)
    private double step;
    @CommandLine.Option(names = {"--rampSchedulePath"},description = "A path to a learning rate schedule also generated by this command.  Used in schedules: ramp",required = false)
    private String rampSchedulePath;


    public ScheduleGenerator() {
    }

    @Override
    public Integer call() throws Exception {
        //
        ISchedule schedule = null;
        switch(scheduler) {
            case "cycle":
                schedule = new CycleSchedule(scheduleType,initialLearningRate,maxLearningRate,cycleLength,annealingLength,annealingDecay);
                break;
            case "exponential":
                schedule = new ExponentialSchedule(scheduleType,initialLearningRate,gamma);
                break;
            case "fixed":
                schedule = new FixedSchedule(initialLearningRate);
                break;
            case "inverse":
                schedule = new InverseSchedule(scheduleType,initialLearningRate,gamma,power);
                break;
            case "map":
                schedule = new MapSchedule(scheduleType, Collections.emptyMap());
                break;
            case "poly":
                schedule = new PolySchedule(scheduleType,initialLearningRate,power,maxIterations);
                break;
            case "ramp":
                File rampSchedule = new File(rampSchedulePath);
                if(!rampSchedule.exists()) {
                    System.err.println("No ramp schedule class found.");
                }
                String json = FileUtils.readFileToString(rampSchedule, Charset.defaultCharset());
                ISchedule rampSchedule2 = ObjectMappers.fromJson(json,ISchedule.class);
                schedule = new RampSchedule(rampSchedule2,maxIterations);
                break;
            case "sigmoid":
                schedule = new SigmoidSchedule(scheduleType,initialLearningRate,gamma,stepSize);
                break;
            case "step":
                schedule = new StepSchedule(scheduleType,initialLearningRate,decayRate,step);
                break;
        }


        System.out.println(ObjectMappers.toJson(schedule));
        return 0;
    }
}
